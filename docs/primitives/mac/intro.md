---
sidebar_position: 1
---

# MAC
In cryptography, a message authentication code (MAC), sometimes known as an authentication tag, is a short piece of information used for authenticating a message.
In other words, to confirm that the message came from the stated sender (its authenticity) and has not been changed.[^1]
The MAC value protects a message's data integrity, as well as its authenticity, by allowing verifiers (who also possess the secret key) to detect any changes to the message content.
```mermaid
graph LR

A([Secret Key <br><em>arbitrary length</em>]) -->C[MAC]
B([Message <br><em>arbitrary length</em>]) -->C[MAC]
C --> F([Authentication Tag<br><em>Fixed length</em><br> <code>d56d54...123</code>])
```
The point of the secret key is to avoid tampering with the tag. Indeed, using only a pre-computed (received) hash an authentication proof is  not secure, as the hash function is not a secret:
```mermaid
graph LR

X([X<br><em>public</em>]) -->HF[Hash Function <br><em>public</em>]
Y([<s>X</s> Y<br><em>public</em>]) -->HF[Hash Function <br><em>public</em>]
HF --> C1(["Hash(X)"])
HF --> C2(["Hash(Y)"])
C1 --> D{=}
C2 --> D2{=}
user1[(Stored Hash for X)] --> D
user2[(Stored Hash for Y)] --> D2
D --> success1{{Authenticated as X}}
D2 --> success2{{Authenticated as Y}}

style Y stroke: red;
style C2 stroke: red;
style user2 stroke: red;
style D2 stroke: red;
style success2 stroke: red;
linkStyle 1 stroke:red;
linkStyle 3 stroke:red;
linkStyle 5 stroke:red;
linkStyle 7 stroke:red;
linkStyle 9 stroke:red;
```

By requiring an additional secret key to compute the authentication tag, we can prevent impersonating another user.
```mermaid
graph LR

X([X<br><em>public</em>]) -->MAC1[MAC<br><em>public</em>]
Y([<s>X</s> Y<br><em>public</em>]) -->MAC2[MAC <br><em>public</em>]
MAC1 --> C1(["MAC(X, key)"])
MAC2 --> C2(["MAC(Y, ?)"])
C1 --> D{=}
C2 --> D2{!=}
secretKey[(Key <br><em>secret</em>)] --> MAC1
secretKey2[(?)] --> MAC2
user1[(Stored MAC for X)] --> D
user2[(Stored MAC for Y)] --> D2
D --> success1{{Authenticated as X}}
D2 --> success2{{Not authenticated as Y}}

style Y stroke: red;
style secretKey2 stroke: red;
style MAC2 stroke: red;
style C2 stroke: red;
style user2 stroke: red;
style D2 stroke: red;
style success2 stroke: red;
linkStyle 1 stroke:red;
linkStyle 3 stroke:red;
linkStyle 5 stroke:red;
linkStyle 7 stroke:red;
linkStyle 9 stroke:red;
linkStyle 11 stroke:red;

```

## Example
```bash
printf "%s" "value" | openssl sha256 -hmac "key"
```

## Application(s)
MAC can be used to provide a **trusted channel**.  
Especially **cookies** rely on MAC to provide a (one-way) trusted communication channel from the client towards the server.
With cookies, a server can securely authenticate clients and trust the information originating from them as being "authentic".
:::note
Cookies as an authentication mechanism doesn't scale well because the server needs to provide a cookie for each client, and store their reference values in a database to perform the authentication later.
:::

## Security
- resistance against forgery: a valid authentication tag can only be generated by the owner of the secret key.

## Limitations / Caveats
:::caution
**MACs can be reused**.  
They don't prevent replays (especially that's why cookies have an expiration date).  
One way to prevent replays is to use a counter or a nonce (a random number that is never reused).
:::

:::caution
**For the resistance against forgery to hold, the secret key must be long enough.**  
At least 16 bytes (128 bits).
:::

:::caution
**MAC verification time should be constant.**  
Otherwise, MACs are subject to timing attacks.[^2]
:::

[^1]: https://en.wikipedia.org/wiki/Message_authentication_code
[^2]: https://en.wikipedia.org/wiki/Timing_attack

